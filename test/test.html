<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Polyfill Tests</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #4CAF50;
            padding-bottom: 10px;
        }
        .test-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-section h2 {
            color: #555;
            margin-top: 0;
        }
        .test-case {
            margin: 15px 0;
            padding: 15px;
            background: #f9f9f9;
            border-left: 4px solid #ddd;
            border-radius: 4px;
        }
        .test-case.pass {
            border-left-color: #4CAF50;
            background: #f1f8f4;
        }
        .test-case.fail {
            border-left-color: #f44336;
            background: #fef1f0;
        }
        .test-case.running {
            border-left-color: #2196F3;
            background: #e3f2fd;
        }
        .test-name {
            font-weight: bold;
            margin-bottom: 8px;
        }
        .test-result {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #666;
        }
        .test-error {
            color: #f44336;
            margin-top: 8px;
            padding: 8px;
            background: #ffebee;
            border-radius: 4px;
            font-size: 12px;
        }
        .summary {
            background: #e3f2fd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            display: flex;
            justify-content: space-around;
            text-align: center;
        }
        .summary div {
            flex: 1;
        }
        .summary .count {
            font-size: 32px;
            font-weight: bold;
            margin: 10px 0;
        }
        .summary .pass .count { color: #4CAF50; }
        .summary .fail .count { color: #f44336; }
        .summary .total .count { color: #2196F3; }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .controls {
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>ðŸ§ª Stream Polyfill Test Suite</h1>
    
    <div class="controls">
        <button id="runTests">Run All Tests</button>
        <button id="clearResults">Clear Results</button>
    </div>

    <div class="summary" id="summary" style="display: none;">
        <div class="total">
            <div>Total Tests</div>
            <div class="count" id="totalCount">0</div>
        </div>
        <div class="pass">
            <div>Passed</div>
            <div class="count" id="passCount">0</div>
        </div>
        <div class="fail">
            <div>Failed</div>
            <div class="count" id="failCount">0</div>
        </div>
    </div>

    <div id="results"></div>
    <script src="https://patrick-ring-motive.github.io/web-streams-shim/web-streams-core.js"></script>
    <script>
        // Test framework
        class TestRunner {
            constructor() {
                this.tests = [];
                this.results = [];
            }

            test(name, fn) {
                this.tests.push({ name, fn });
            }

            async runAll() {
                this.results = [];
                const resultsDiv = document.getElementById('results');
                resultsDiv.innerHTML = '';

                for (const test of this.tests) {
                    const testDiv = this.createTestElement(test.name, 'running');
                    resultsDiv.appendChild(testDiv);

                    try {
                        await test.fn();
                        this.updateTestElement(testDiv, 'pass', 'Passed âœ“');
                        this.results.push({ name: test.name, passed: true });
                    } catch (error) {
                        this.updateTestElement(testDiv, 'fail', 'Failed âœ—', error.message);
                        this.results.push({ name: test.name, passed: false, error: error.message });
                    }
                }

                this.updateSummary();
            }

            createTestElement(name, status) {
                const section = document.querySelector(`#section-${name.split(':')[0].replace(/\s+/g, '-')}`) || 
                               this.createSection(name.split(':')[0]);
                
                const div = document.createElement('div');
                div.className = `test-case ${status}`;
                div.innerHTML = `
                    <div class="test-name">${name}</div>
                    <div class="test-result">Running...</div>
                `;
                section.appendChild(div);
                return div;
            }

            createSection(title) {
                const section = document.createElement('div');
                section.className = 'test-section';
                section.id = `section-${title.replace(/\s+/g, '-')}`;
                section.innerHTML = `<h2>${title}</h2>`;
                document.getElementById('results').appendChild(section);
                return section;
            }

            updateTestElement(div, status, result, error = null) {
                div.className = `test-case ${status}`;
                div.querySelector('.test-result').textContent = result;
                if (error) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'test-error';
                    errorDiv.textContent = error;
                    div.appendChild(errorDiv);
                }
            }

            updateSummary() {
                const total = this.results.length;
                const passed = this.results.filter(r => r.passed).length;
                const failed = total - passed;

                document.getElementById('summary').style.display = 'flex';
                document.getElementById('totalCount').textContent = total;
                document.getElementById('passCount').textContent = passed;
                document.getElementById('failCount').textContent = failed;
            }
        }

        const runner = new TestRunner();

        // Helper functions
        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        function assertEqual(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(message || `Expected ${expected}, got ${actual}`);
            }
        }

        async function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ReadableStream Iterator Tests
        runner.test('ReadableStream Iterator: next() method exists', async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue('test');
                    controller.close();
                }
            });
            const reader = stream.getReader();
            assert(typeof reader.next === 'function', 'next() method should exist');
        });

        runner.test('ReadableStream Iterator: next() reads chunks', async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue('chunk1');
                    controller.enqueue('chunk2');
                    controller.close();
                }
            });
            const reader = stream.getReader();
            const result1 = await reader.next();
            assertEqual(result1.value, 'chunk1', 'First chunk should be chunk1');
            assertEqual(result1.done, false, 'Should not be done');
            const result2 = await reader.next();
            assertEqual(result2.value, 'chunk2', 'Second chunk should be chunk2');
        });

        runner.test('ReadableStream Iterator: Symbol.asyncIterator on reader', async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue(1);
                    controller.enqueue(2);
                    controller.close();
                }
            });
            const reader = stream.getReader();
            assert(typeof reader[Symbol.asyncIterator] === 'function', 'Symbol.asyncIterator should exist');
            assertEqual(reader[Symbol.asyncIterator](), reader, 'Should return itself');
        });

        runner.test('ReadableStream Iterator: for-await-of on reader', async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue(1);
                    controller.enqueue(2);
                    controller.enqueue(3);
                    controller.close();
                }
            });
            const reader = stream.getReader();
            const values = [];
            for await (const value of reader) {
                values.push(value);
            }
            assertEqual(values.length, 3, 'Should read 3 values');
            assertEqual(values[0], 1, 'First value should be 1');
            assertEqual(values[2], 3, 'Third value should be 3');
        });

        runner.test('ReadableStream Iterator: return() method', async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue(1);
                    controller.enqueue(2);
                    controller.enqueue(3);
                    controller.close();
                }
            });
            const reader = stream.getReader();
            assert(typeof reader.return === 'function', 'return() method should exist');
            await reader.next();
            const result = await reader.return('stopped');
            assert(result.done, 'Should be done after return');
        });

        runner.test('ReadableStream Iterator: throw() method', async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue(1);
                    controller.close();
                }
            });
            const reader = stream.getReader();
            assert(typeof reader.throw === 'function', 'throw() method should exist');
            const result = await reader.throw(new Error('test error'));
            assert(result.done, 'Should be done after throw');
        });

        // ReadableStream Direct Iterator Tests
        runner.test('ReadableStream Direct: Symbol.asyncIterator on stream', async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue(1);
                    controller.close();
                }
            });
            assert(typeof stream[Symbol.asyncIterator] === 'function', 'Symbol.asyncIterator should exist on stream');
        });

        runner.test('ReadableStream Direct: for-await-of on stream', async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue('a');
                    controller.enqueue('b');
                    controller.enqueue('c');
                    controller.close();
                }
            });
            const values = [];
            for await (const value of stream) {
                values.push(value);
            }
            assertEqual(values.join(''), 'abc', 'Should read all values');
        });

        runner.test('ReadableStream Direct: values() method', async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue(10);
                    controller.enqueue(20);
                    controller.close();
                }
            });
            assert(typeof stream.values === 'function', 'values() method should exist');
            const values = [];
            for await (const value of stream.values()) {
                values.push(value);
            }
            assertEqual(values.length, 2, 'Should read 2 values');
        });

        // ReadableStream.from() Tests
        runner.test('ReadableStream.from: exists as static method', async () => {
            assert(typeof ReadableStream.from === 'function', 'ReadableStream.from should exist');
        });

        runner.test('ReadableStream.from: creates stream from array', async () => {
            const stream = ReadableStream.from([1, 2, 3]);
            const values = [];
            for await (const value of stream) {
                values.push(value);
            }
            assertEqual(values.length, 3, 'Should have 3 values');
            assertEqual(values[1], 2, 'Second value should be 2');
        });

        runner.test('ReadableStream.from: creates stream from generator', async () => {
            function* gen() {
                yield 'a';
                yield 'b';
                yield 'c';
            }
            const stream = ReadableStream.from(gen());
            const values = [];
            for await (const value of stream) {
                values.push(value);
            }
            assertEqual(values.join(''), 'abc', 'Should read all generated values');
        });

        runner.test('ReadableStream.from: creates stream from async generator', async () => {
            async function* asyncGen() {
                yield Promise.resolve(1);
                yield Promise.resolve(2);
            }
            const stream = ReadableStream.from(asyncGen());
            const values = [];
            for await (const value of stream) {
                values.push(value);
            }
            assertEqual(values.length, 2, 'Should have 2 values from async generator');
        });

        // Request/Response Body Tests
        runner.test('Request/Response: Request has body property', async () => {
            const req = new Request('https://example.com', {
                method: 'POST',
                body: 'test data'
            });
            assert(req.body !== undefined, 'Request should have body property');
        });

        runner.test('Request/Response: Response has body property', async () => {
            const res = new Response('test data');
            assert(res.body !== undefined, 'Response should have body property');
        });

        runner.test('Request/Response: body is ReadableStream', async () => {
            const res = new Response('test data');
            assert(res.body instanceof ReadableStream, 'body should be a ReadableStream');
        });

        runner.test('Request/Response: can read body chunks', async () => {
            const res = new Response('hello world');
            const reader = res.body.getReader();
            const { value, done } = await reader.read();
            assert(value instanceof Uint8Array, 'Chunk should be Uint8Array');
            assert(!done, 'Should not be done after first read');
        });

        runner.test('Request/Response: bodyUsed property', async () => {
            const res = new Response('test');
            assert(typeof res.bodyUsed === 'boolean', 'bodyUsed should be boolean');
        });

        // bytes() Method Tests
        runner.test('bytes(): Response.bytes() exists', async () => {
            const res = new Response('test');
            assert(typeof res.bytes === 'function', 'bytes() should exist on Response');
        });

        runner.test('bytes(): returns Uint8Array', async () => {
            const res = new Response('hello');
            const bytes = await res.bytes();
            assert(bytes instanceof Uint8Array, 'bytes() should return Uint8Array');
        });

        runner.test('bytes(): correct data', async () => {
            const res = new Response('ABC');
            const bytes = await res.bytes();
            assert(bytes.length > 0, 'Should have bytes');
            // Check if it contains expected byte values
            assertEqual(bytes[0], 65, 'First byte should be 65 (A)');
        });

        runner.test('bytes(): Blob.bytes() exists', async () => {
            const blob = new Blob(['test']);
            assert(typeof blob.bytes === 'function', 'bytes() should exist on Blob');
        });

        runner.test('bytes(): Blob.bytes() returns data', async () => {
            const blob = new Blob(['hello']);
            const bytes = await blob.bytes();
            assert(bytes instanceof Uint8Array, 'Blob bytes() should return Uint8Array');
            assert(bytes.length > 0, 'Should have bytes');
        });

        // ReadableStreamDefaultReader Constructor Tests
        runner.test('ReadableStreamDefaultReader: constructor works', async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue('test');
                    controller.close();
                }
            });
            const reader = new ReadableStreamDefaultReader(stream);
            assert(reader instanceof ReadableStreamDefaultReader, 'Should be instance of ReadableStreamDefaultReader');
        });

        runner.test('ReadableStreamDefaultReader: can read after construction', async () => {
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue('data');
                    controller.close();
                }
            });
            const reader = new ReadableStreamDefaultReader(stream);
            const result = await reader.read();
            assertEqual(result.value, 'data', 'Should read correct value');
        });

        // Integration Tests
        runner.test('Integration: Stream pipeline', async () => {
            const data = [1, 2, 3, 4, 5];
            const stream = ReadableStream.from(data);
            
            let sum = 0;
            for await (const num of stream) {
                sum += num;
            }
            
            assertEqual(sum, 15, 'Sum should be 15');
        });

        runner.test('Integration: Early termination with break', async () => {
            const stream = new ReadableStream({
                start(controller) {
                    for (let i = 0; i < 100; i++) {
                        controller.enqueue(i);
                    }
                    controller.close();
                }
            });
            
            const values = [];
            for await (const value of stream) {
                values.push(value);
                if (value >= 4) break;
            }
            
            assert(values.length <= 5, 'Should stop early');
        });

        // Event listeners
        document.getElementById('runTests').addEventListener('click', async () => {
            const button = document.getElementById('runTests');
            button.disabled = true;
            button.textContent = 'Running...';
            
            await runner.runAll();
            
            button.disabled = false;
            button.textContent = 'Run All Tests';
        });

        document.getElementById('clearResults').addEventListener('click', () => {
            document.getElementById('results').innerHTML = '';
            document.getElementById('summary').style.display = 'none';
        });

        // Auto-run on load
        window.addEventListener('load', () => {
            console.log('Test suite loaded. Click "Run All Tests" to begin.');
        });
    </script>
</body>
</html>
